# Verilog
Verilog Brick Break and Pong Game

The game created for this lab is a 2 player Pong and Brick Breaker versus game; each player controls a paddle with vertical exclusive movement and tries to score points by destroying the blocks spawned in. The paddles are controlled by the up, down, left, and right button on the FPGA. Player 1 is denoted by the red color and player 2 is denoted by the green color to give the game a vintage feel by alluding to everyone’s favorite plumbing brothers. The game starts by spawning 120 blocks and 2 balls, 1 red ball and 1 green ball. The ball’s color changes depending on who was the last one to hit that specific ball. When a ball makes contact with a block the points are given to the player who last hit that ball, which is visibly easy to tell by the color of the ball. The red and green balls will always initially go in opposite horizontal directions, and one will go up, the other down. This ensures that the initial state of the balls is fair to both players, as the game map is vertically and horizontally symmetrical.

In addition, the paddles have been slightly modified from their original design. Instead of making the ball’s future direction based on its previous direction, the player can control whether the ball goes up or down depending on which side of the paddle makes contact with the ball; if the ball makes contact with the top half of the paddle then the ball will always go up, and if the ball makes contact with the bottom half of the paddle then the ball will always go down. This is implemented by creating a full-sized paddle out of 2 half paddles that are right next to each other and move together to visually look like 1 paddle. Each half paddle has the collision detection range of a full paddle to ensure that when one paddle is blocked, the other paddle does not continue moving. The Verilog code is changed to always decrement the ball’s next y-position (send it up) for the top half of the paddle, and increment the ball’s next y-position (send it down) for the bottom half of the paddle.

The FSM has an idle state, a play game state, a player 1 wins state, and a player 2 wins state. In idle, the user is able to add more coins to the game by using the up directional button on the FPGA. To go to the play game state, the center directional button must be pressed and there must be at least 1 coin in the game. When the FSM changes from idle to play game, 1 coin is subtracted and the coin total is still remembered by the game. The play game state continues until a player reaches the winning score of 50 and the state changes depending on which player reaches the score first; player 1 wins if player 1 is the first player to reach 50 points and player 2 wins if player 2 is the first player to reach 50 points. In the very rare occurrence that a tie would result from both players reaching 50 points at the same clock cycle, player 1 is declared the winner for simplicity. From either of these player wins states, the user can return back to the idle state by pushing the center directional button. Upon returning to this state the game again displays how many coins the user has and the user can play again by pressing the center directional button while having at least 1 coin.

The game detects whether a ball destroys a block using a handful of registers in the top module and in the ball(s). The ball has a single-bit register that stores the player that last hit it (0 or 1), this state determines the ball’s draw color and scoring contribution. Since the blocks are too far apart for a ball to strike two blocks simultaneously, if the ball detects a block collision, it outputs the bit ‘broken0’ or ‘broken1’ depending on the state of the ‘player’ bit. In the top module there is an array ‘broken0[n-1,0]’ and ‘broken1[n-1,0]’ for n balls (2 by default) that stores the current ‘broken0’ and ‘broken1’ states for all balls. Each physics frame, the registers ‘prev_broken0’ and  ‘prev_broken1’ are subtracted from the current registers to debounce the scoring, and the resulting register(s) are called ‘add0’ and ‘add1’. These are added to each players scores each frame and then reset for the next frame. The ‘score0’ and ‘score1’ registers are fed into the score modules in the game screen, and display both scores in the upper left and right corners.

A new module called ‘char’ was developed based upon the score module. This module only displays 1 8x8 character, ‘A-Z’, ‘1’, ‘2’, space and ‘:’ (encoded 0-29). The bit maps made for each character were provided by Chat-GPT after a few were handmade so that it would have a pattern to use, it did well without much assistance. These characters are tediously placed in each instance where they are needed because a ‘string’ module was not made. These characters output to draw vectors that are scene specific, such that the game-state machine can toggle them on or off. The draw conditions were refactored to allow for more vectors to be used.
